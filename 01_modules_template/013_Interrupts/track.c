##########################################################################################


##########################################################################################


##########################################################################################


##########################################################################################
Interrupts and Exceptions

Exceptions: are often discussed at the same time as interrupts. 
- Unlike interrupts, "exceptions occur synchronously with respect to the processor clock"; 
- they are often called synchronous interrupts. 
- Exceptions are produced by the processor while executing instructions either in response 
to a programming error (e.g. divide by zero) or abnormal conditions that must be handled 
by the kernel (e.g. a page fault). 
- Because many processor architectures handle exceptions in a similar manner to interrupts,
the kernel infrastructure for handling the two is similar.

Simple definitions of the two:
Interrupts: asynchronous interrupts generated by hardware.
Exceptions: synchronous interrupts generated by the processor.

- "System calls" (one "type of exception") on the x86 architecture are implemented by the 
issuance of a software interrupt, which traps into the kernel and causes the execution of 
a special system call handler. 
- Interrupts work in a similar way, except hardware (not software) issues interrupts.
------------------------------------------------------------------------------------------
There is a further classification of interrupts and exceptions.

Interrupts
Maskable: All Interrupt Requests (IRQs) issued by I/O devices give rise to maskable 
interrupts. 
- A maskable interrupt can be in two states: masked or unmasked; 
a masked interrupt is ignored by the control unit as long as it remains masked.

Non_maskable: Only a few critical events (such as hardware failures) give rise to 
nonmaskable interrupts. Non-maskable interrupts are always recognized by the CPU.
------------------------------------------------------------------------------------------
Exceptions

Falts:Like Divide by zero, Page Fault, Segmentation Fault.
Traps:Reported immediately following the execution of the trapping instruction. 
Like Breakpoints.
Aborts:Aborts are used to report severe errors, such as hardware failures and invalid or 
inconsistent values in system tables.
------------------------------------------------------------------------------------------
- For a device’s each interrupt, its device driver must register an interrupt handler.

Interrupt_handler:
- An interrupt handler or interrupt service routine (ISR) is the function that the kernel 
runs in response to a specific interrupt:

- Each device that generates interrupts has an associated interrupt handler.
- The interrupt handler for a device is part of the device’s driver (the kernel code that 
manages the device).
- In Linux, interrupt handlers are normal C functions, which match a specific prototype 
and thus enable the kernel to pass the handler information in a standard way. 
- "What differentiates interrupt handlers from other kernel functions" is that the kernel 
invokes them in "response to interrupts" and that they run in a special context called 
"interrupt context". 
- This special context is occasionally called "atomic context" because code executing in 
this context is "unable to block", must not sleep.
>> Either - when CPU executes in interrupt context - it just executes a snippet of code
- either function ISR - and if in this context - sleep() is called - This "context" of code
does not have a process backing it up - so we have no way to identify this context of code
execution if we want to schedule it back - so that we can get back to this context after sleeping - since it is not a process - scheduler understands only process/task switching
- When interrupt occurs - process/thread/task is not created for ISR to be exeucted - hence
in the ISR - TOP Half executuion - there must be no blocking
>> Hence the statement - Interrupts are non-schedulable entities
>> When trying to understand this - just forget - the Interrupt Context is executed using
process's address space - like stack - Then it becomes clear that - Interrupt execution
is not backed by any process - so calling sleep() - which may sleep - but the scheduler
does not know how to get back to the interrupt code - as it was not a process/thread
running - it was just a function ISR execution - and it is not a process to be scheduled
(ofcourse it can get back - using the process which was interrupted - but may have 
undefined behaviour)
>> If we want we can have - Bottom halfs - which can be Threads
------------------------------------------------------------------------------------------
- Because an interrupt can occur at any time, an interrupt handler can be executed at any 
time. 
- It is imperative that the handler runs quickly, to resume the execution of the 
interrupted code as soon as possible. 

- It is important that
To the hardware: the operating system services the interrupt without delay.
To the rest of the system: the interrupt handler executes in as short a period as possible.

- At the very least, an interrupt handler’s job is to acknowledge the interrupt’s receipt 
to the hardware. 
- However, interrupt handlers can often have a large amount of work to perform.
------------------------------------------------------------------------------------------
Process Context and Interrupt Context

- The kernel accomplishes useful work using a combination of process contexts and 
interrupts context. 
- Kernel code that services system calls issued by user applications runs on behalf of the 
corresponding application processes and is said to execute in the process context. 
- Interrupt handlers, on the other hand, run asynchronously in the interrupt context. 

- "Process contexts are not tied to any interrupt context and vice versa"

- Kernel code running in process context is preemptible. 
- An interrupt context, however, always runs to completion and is not preemptible. 
- Because of this, there are restrictions on what can be done from an interrupt context. 
- Code executing from interrupt context cannot do the following:

1. Go to sleep or relinquish the processor
2. Acquire a mutex
3. Perform time-consuming tasks
4. Access user space virtual memory
------------------------------------------------------------------------------------------
- Based on our idea, ISR or Interrupt Handler should be executed very quickly and it 
should not run for more time (it should not perform time-consuming tasks). 

- What if, I want to do a huge amount of work upon receiving interrupts"?" 
- So it is a problem, right"?" If we take more time to process, this will happen.

1. While the highest priority ISR is running, it doesn’t let other interrupts to run.
2. Interrupts with the same type will be missed.
3. To eliminate that problem, the processing of interrupts is split into 
two parts or halves:

1. Top halves
2. Bottom halves
------------------------------------------------------------------------------------------
Top halves and Bottom halves

Top_half:
- The interrupt handler(ISR) is the top half. 
- The top half will run immediately upon receipt of the interrupt and performs only the 
work that is time-critical, such as acknowledging receipt of the interrupt or resetting 
the hardware.

Bottom_half:
- The bottom half is used to process data, letting the top half to deal with new incoming 
interrupts. 
- Interrupts are enabled when a bottom half runs. 
- The interrupt can be disabled if necessary, but generally, this should be avoided as 
this goes against the basic purpose of having a bottom half – processing data while 
listening to new interrupts. 
- The bottom half runs in the future, at a more convenient time, with all 
interrupts enabled.
------------------------------------------------------------------------------------------
For example, using the network card:

- When network cards receive packets from the network, the network cards immediately 
issue an interrupt. 
- This optimizes network throughput and latency and avoids timeouts.
- The kernel responds by executing the network card’s registered interrupt.
- The interrupt runs, acknowledges the hardware, copies the new networking packets 
into the main memory, and readies the network card for more packets. 
- These jobs are important, time-critical, and hardware-specific work.
- The kernel generally needs to quickly copy the networking packet into the main memory 
because the network data buffer on the networking card is fixed and minuscule in size, 
particularly compared to the main memory. 
- Delays in copying the packets can result in a buffer overrun, with incoming packets 
overwhelming the networking card’s buffer and thus packets being dropped.
- After the networking data is safely in the main memory, the interrupt’s job is done, 
and it can return control of the system to whatever code was interrupted when the 
interrupt was generated.
- The rest of the processing and handling of the packets occurs later, in the bottom half.

- If the interrupt handler function could process and acknowledge interrupts within a few 
microseconds consistently, then absolutely there is no need for top half/bottom half 
delegation.
------------------------------------------------------------------------------------------
There are 4 bottom half mechanisms are available in Linux:

1. Workqueue
2. Threaded IRQs
3. Softirq
4. Tasklets

##########################################################################################
							Interrupt Example Program in Linux Kernel

- Before writing any interrupt program, you should keep the following points in mind.

- Interrupt handlers can not enter sleep, so to avoid calls to some functions which has 
sleep.

- When the interrupt handler has part of the code to enter the critical section, use 
spinlocks lock, rather than mutexes. 
- Because if it couldn’t take mutex it will go to sleep until it takes the mute.

- "Interrupt handlers can not exchange data with the userspace"

- The interrupt handlers must be executed as soon as possible. To ensure this, it is best 
to split the implementation into two parts, the top half and the bottom half. 

- The top half of the handler will get the job done as soon as possible and then work 
late on the bottom half, which can be done with softirq or tasklet or workqueue.

- Interrupt handlers can not be called repeatedly. When a handler is already executing, 
its corresponding IRQ must be disabled until the handler is done.

- Interrupt handlers can be interrupted by higher authority handlers. 
- If you want to avoid being interrupted by a highly qualified handler, you can mark the 
interrupt handler as a fast handler. 

- However, if too many are marked as fast handlers, the performance of the system will be 
degraded, because the interrupt latency will be longer.
------------------------------------------------------------------------------------------
Functions Related to Interrupt

- Before programming, we should know the basic functions which are useful for interrupts. 

This table explains the usage of all functions.

##########################################################################################

request_irq( unsigned int irq, irq_handler_t handler, unsigned long flags, const char *name,
						 void *dev_id)

Register an IRQ, the parameters are as follows:

irq: IRQ number to allocate

handler: This is Interrupt handler function.This function will be invoked whenever the 
operating system receives the interrupt.
- The data type of return is irq_handler_t, if its return value is IRQ_HANDLED, 
it indicates that the processing is completed successfully, but if the return value is 
IRQ_NONE, the processing fails.

flags: can be either zero or a bit mask of one or more of the flags defined in 
linux/interrupt.h. The most important of these flags are:
IRQF_DISABLED
IRQF_SAMPLE_RANDOM
IRQF_SHARED
IRQF_TIMER
(Explained after this table)

name: Used to identify the device name using this IRQ, for example, 
cat /proc/interrupts will list the IRQ number and device name.

dev_id: IRQ shared by many devices. When an interrupt handler is freed, dev provides a 
unique cookie to enable the removal of only the desired interrupt handler from the 
interrupt line. 
- Without this parameter, it would be impossible for the kernel to know which handler to 
remove on a given interrupt line. 
- You can pass NULL here if the line is not shared, but you must pass a unique cookie 
if your interrupt line is shared. 
- This pointer is also passed into the interrupt handler on each invocation. 
- A common practice is to pass the driver's device structure. 
- This pointer is unique and might be useful to have within the handlers.

Return
returns zero on success and nonzero value indicates an error.

request_irq() cannot be called from interrupt context 
(other situations where code cannot block), because it can block.

##########################################################################################

free_irq(unsigned int irq, void *dev_id)

Release an IRQ registered by request_irq() with the following parameters:

irq: IRQ number.
dev_id: is the last parameter of request_irq.

- If the specified interrupt line is not shared, this function removes the handler and 
disables the line.

- If the interrupt line is shared, the handler identified via dev_id is removed, but the 
interrupt line is disabled only when the last handler is removed. 

- With shared interrupt lines, a unique cookie is required to differentiate between the 
multiple handlers that can exist on a single line and enable free_irq() to remove only 
the correct handler.

- In either case (shared or unshared), if dev_id is non-NULL, it must match the desired 
handler. A call to free_irq() must be made from process context.

##########################################################################################

enable_irq(unsigned int irq)

Re-enable interrupt disabled by disable_irq or disable_irq_nosync.
------------------------------------------------------------------------------------------
disable_irq(unsigned int irq)
Disable an IRQ from issuing an interrupt.
------------------------------------------------------------------------------------------
disable_irq_nosync(unsigned int irq)	Disable an IRQ from issuing an interrupt, but wait until there is an interrupt handler being executed.
------------------------------------------------------------------------------------------
in_irq()	
returns true when in interrupt handler
------------------------------------------------------------------------------------------
in_interrupt()	
returns true when in interrupt handler or bottom half

##########################################################################################
Interrupts Flags

- These are the second parameter of the function. It has several flags. 
Here I explained important flags.

IRQF_DISABLED:
- When set, this flag instructs the kernel to disable all interrupts when executing this 
interrupt handler.
- When unset, interrupt handlers run with all interrupts except their own enabled.
- Most interrupt handlers do not set this flag, as disabling all interrupts is bad form. 
- Its use is reserved for performance-sensitive interrupts that execute quickly. 
- This flag is the current manifestation of the SA_INTERRUPT flag, which in the past 
distinguished between “fast” and “slow” interrupts.

IRQF_SAMPLE_RANDOM:
- This flag specifies that interrupts generated by this device should contribute to the 
kernel entropy pool. 
- The kernel entropy pool provides truly random numbers derived from various random events.
- If this flag is specified, the timing of interrupts from this device is fed to the pool 
as entropy. 
- Do not set this if your device issues interrupt at a predictable rate 
(e.g. the system timer) or can be influenced by external attackers 
(e.g. a networking device). 
- On the other hand, most other hardware generates an interrupt at non-deterministic 
times and is, therefore, a good source of entropy.

IRQF_TIMER:
- This flag specifies that this handler process interrupts the system timer.

IRQF_SHARED: 
- This flag specifies that the interrupt line can be shared among multiple interrupt 
handlers. 
- Each handler registered on a given line must specify this flag; otherwise, only one 
handler can exist per line.
------------------------------------------------------------------------------------------
Registering an Interrupt Handler

#define IRQ_NO 11

if (request_irq(IRQ_NO, irq_handler, IRQF_SHARED, "etx_device", (void *)(irq_handler))) {
            printk(KERN_INFO "my_device: cannot register IRQ ");
            goto irq;
}
------------------------------------------------------------------------------------------
Freeing an Interrupt Handler

free_irq(IRQ_NO,(void *)(irq_handler));
------------------------------------------------------------------------------------------
Interrupt Handler

static irqreturn_t irq_handler(int irq,void *dev_id) {
  printk(KERN_INFO "Shared IRQ: Interrupt Occurred");
  return IRQ_HANDLED;
}
------------------------------------------------------------------------------------------
Interrupt Example Program in Linux Kernel – Programming

- The interrupt can be coming from anywhere (any hardware) and anytime. 
- In our tutorial, we are not going to use any hardware. Here instead of using hardware, 
we are going to trigger interrupt by simulating. 
- If you have only a PC (without hardware), but you want to play around with Interrupts 
in Linux you can follow our method. 
- If you have the hardware, then I would request not to use this method. 
- Instead, you can use the hardware interrupts. We have covered the hardware interrupt in 
this tutorial.
------------------------------------------------------------------------------------------
Triggering Hardware Interrupt through Software

- Intel processors handle interrupt using IDT (Interrupt Descriptor Table).  
- The IDT consists of 256 entries with each entry corresponding to a vector and of 8 bytes.
- All the entries are a pointer to the interrupt handling function. 
- The CPU uses IDTR to point to IDT. 
- The relation between those two can be depicted as below,

IDTR Register : [ IDT Base Address ] | [ IDT Limit ]
>> The IDT Base address is obtained + IDT Limit -> To get to the IDT Table:
IDT Table has 256 entries - and each entry is 8-bytes
- Also each entry is treated as : Gate for interrupt #n

- An interrupt can be programmatically raised using ‘int’ instruction. 
- For example, the Linux system call was using int $0x80 - for system call trap

- In Linux IRQ to vector, mapping is done in arch/x86/include/asm/irq_vectors.h 
- The used vector range is as follows,

Vectors [0 to 31]   : System Traps and Exceptions - hardcoded events
Vectors [32 to 127] : External device Interrupts
Vectors [128]       : Legacy "int 0x80" syscall interface Trap instruction
Vectors [129 to INVALIDATE_TLB_VECTOR_START-1 excpet 204] : Device interrupts
Vectors [INVALIDATE_TLB_VECTOR_START to 255] : Special interrupts


The IRQ0 is mapped to vector using the macro,

#define IRQ0_VECTOR (FIRST_EXTERNAL_VECTOR + 0x10)
>> 0x10 is already mapped like this in kernel - we are re-using the MACRO : IRQ0_VECTOR

where, FIRST_EXTERNAL_VECTOR = 0x20 (32 in decimal)

So if we want to raise an interrupt IRQ11, programmatically we have to add 11 to a vector of IRQ0.

0x20 + 0x10 + 11 = 0x3B (59 in Decimal).

Hence executing “asm("int $0x3B")“, will raise interrupt IRQ 11.

The instruction will be executed while reading the device file of our driver 
(/dev/etx_device).

##########################################################################################

/***************************************************************************//**
*  \file       driver.c
*
*  \details    Interrupt Example
*
*  \author     EmbeTronicX
*
*******************************************************************************/
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/module.h>
#include <linux/kdev_t.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/device.h>
#include<linux/slab.h>                 //kmalloc()
#include<linux/uaccess.h>              //copy_to/from_user()
#include<linux/sysfs.h> 
#include<linux/kobject.h> 
#include <linux/interrupt.h>
#include <asm/io.h>
#include <linux/err.h>
#define IRQ_NO 11

//Interrupt handler for IRQ 11. 
static irqreturn_t irq_handler(int irq,void *dev_id) {
  printk(KERN_INFO "Shared IRQ: Interrupt Occurred");
  return IRQ_HANDLED;
}

volatile int etx_value = 0;
 
dev_t dev = 0;
static struct class *dev_class;
static struct cdev etx_cdev;
struct kobject *kobj_ref;
 
static int __init etx_driver_init(void);
static void __exit etx_driver_exit(void);

/*************** Driver Fuctions **********************/
static int etx_open(struct inode *inode, struct file *file);
static int etx_release(struct inode *inode, struct file *file);
static ssize_t etx_read(struct file *filp, 
                char __user *buf, size_t len,loff_t * off);
static ssize_t etx_write(struct file *filp, 
                const char *buf, size_t len, loff_t * off);

/*************** Sysfs Fuctions **********************/
static ssize_t sysfs_show(struct kobject *kobj, 
                struct kobj_attribute *attr, char *buf);
static ssize_t sysfs_store(struct kobject *kobj, 
                struct kobj_attribute *attr,const char *buf, size_t count);

struct kobj_attribute etx_attr = __ATTR(etx_value, 0660, sysfs_show, sysfs_store);
 
static struct file_operations fops =
{
        .owner          = THIS_MODULE,
        .read           = etx_read,
        .write          = etx_write,
        .open           = etx_open,
        .release        = etx_release,
};
 
static ssize_t sysfs_show(struct kobject *kobj, 
                struct kobj_attribute *attr, char *buf)
{
        printk(KERN_INFO "Sysfs - Read!!!\n");
        return sprintf(buf, "%d", etx_value);
}

static ssize_t sysfs_store(struct kobject *kobj, 
                struct kobj_attribute *attr,const char *buf, size_t count)
{
        printk(KERN_INFO "Sysfs - Write!!!\n");
        sscanf(buf,"%d",&etx_value);
        return count;
}

static int etx_open(struct inode *inode, struct file *file)
{
        printk(KERN_INFO "Device File Opened...!!!\n");
        return 0;
}
 
static int etx_release(struct inode *inode, struct file *file)
{
        printk(KERN_INFO "Device File Closed...!!!\n");
        return 0;
}
 
static ssize_t etx_read(struct file *filp, 
                char __user *buf, size_t len, loff_t *off)
{
        printk(KERN_INFO "Read function\n");
        asm("int $0x3B");  // Corresponding to irq 11
        return 0;
}

static ssize_t etx_write(struct file *filp, 
                const char __user *buf, size_t len, loff_t *off)
{
        printk(KERN_INFO "Write Function\n");
        return len;
}
 
static int __init etx_driver_init(void)
{
        /*Allocating Major number*/
        if((alloc_chrdev_region(&dev, 0, 1, "etx_Dev")) <0){
                printk(KERN_INFO "Cannot allocate major number\n");
                return -1;
        }
        printk(KERN_INFO "Major = %d Minor = %d \n",MAJOR(dev), MINOR(dev));
 
        /*Creating cdev structure*/
        cdev_init(&etx_cdev,&fops);
 
        /*Adding character device to the system*/
        if((cdev_add(&etx_cdev,dev,1)) < 0){
            printk(KERN_INFO "Cannot add the device to the system\n");
            goto r_class;
        }
 
        /*Creating struct class*/
        if(IS_ERR(dev_class = class_create(THIS_MODULE,"etx_class"))){
            printk(KERN_INFO "Cannot create the struct class\n");
            goto r_class;
        }
 
        /*Creating device*/
        if(IS_ERR(device_create(dev_class,NULL,dev,NULL,"etx_device"))){
            printk(KERN_INFO "Cannot create the Device 1\n");
            goto r_device;
        }
 
        /*Creating a directory in /sys/kernel/ */
        kobj_ref = kobject_create_and_add("etx_sysfs",kernel_kobj);
 
        /*Creating sysfs file for etx_value*/
        if(sysfs_create_file(kobj_ref,&etx_attr.attr)){
                printk(KERN_INFO"Cannot create sysfs file......\n");
                goto r_sysfs;
        }
        if (request_irq(IRQ_NO, irq_handler, IRQF_SHARED, "etx_device", (void *)(irq_handler))) {
            printk(KERN_INFO "my_device: cannot register IRQ ");
                    goto irq;
        }
        printk(KERN_INFO "Device Driver Insert...Done!!!\n");
    return 0;

irq:
        free_irq(IRQ_NO,(void *)(irq_handler));

r_sysfs:
        kobject_put(kobj_ref); 
        sysfs_remove_file(kernel_kobj, &etx_attr.attr);
 
r_device:
        class_destroy(dev_class);
r_class:
        unregister_chrdev_region(dev,1);
        cdev_del(&etx_cdev);
        return -1;
}
 
static void __exit etx_driver_exit(void)
{
        free_irq(IRQ_NO,(void *)(irq_handler));
        kobject_put(kobj_ref); 
        sysfs_remove_file(kernel_kobj, &etx_attr.attr);
        device_destroy(dev_class,dev);
        class_destroy(dev_class);
        cdev_del(&etx_cdev);
        unregister_chrdev_region(dev, 1);
        printk(KERN_INFO "Device Driver Remove...Done!!!\n");
}
 
module_init(etx_driver_init);
module_exit(etx_driver_exit);
 
MODULE_LICENSE("GPL");
MODULE_AUTHOR("EmbeTronicX <[email protected]>");
MODULE_DESCRIPTION("A simple device driver - Interrupts");
MODULE_VERSION("1.9");

##########################################################################################

Building and Testing Driver
Build the driver by using Makefile (sudo make)
Load the driver using sudo insmod driver.ko
To trigger the interrupt read device file (sudo cat /dev/etx_device)
Now see the Dmesg (dmesg)
[email protected]: dmesg

[19743.366386] Major = 246 Minor = 0
[19743.370707] Device Driver Insert...Done!!!
[19745.580487] Device File Opened...!!!
[19745.580507] Read function
[19745.580531] Shared IRQ: Interrupt Occurred
[19745.580540] Device File Closed...!!!
We can able to see the print “Shared IRQ: Interrupt Occurred“
Unload the module using sudo rmmod driver
##########################################################################################

A problem in New Linux kernel
If you are using the newer Linux kernel, then this may not work properly. You may get something like below.

do_IRQ: 1.59 No irq handler for vector

In order to solve that, you have to change the Linux kernel source code, Compile it, then install it.

Changes_needed_in_kernel:
Step 5: Now we have the source code and tools that needed to compile. Let’s do our modification. Add the below line in the downloaded Linux kernel file arch/x86/kernel/irq.c right after all the include lines.

EXPORT_SYMBOL (vector_irq);

##########################################################################################

/***************************************************************************//**
*  \file       driver.c
*
*  \details    Interrupt Example
*
*  \author     EmbeTronicX
*
*  \Tested with kernel 5.4.47
*
*******************************************************************************/
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/module.h>
#include <linux/kdev_t.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/device.h>
#include<linux/slab.h>                 //kmalloc()
#include<linux/uaccess.h>              //copy_to/from_user()
#include<linux/sysfs.h> 
#include<linux/kobject.h> 
#include <linux/interrupt.h>
#include <asm/io.h>
#include <asm/hw_irq.h>
#include <linux/err.h>

#define IRQ_NO 11
 
//Interrupt handler for IRQ 11. 
static irqreturn_t irq_handler(int irq,void *dev_id) 
{
  printk(KERN_INFO "Shared IRQ: Interrupt Occurred");
  return IRQ_HANDLED;
}

static ssize_t etx_read(struct file *filp, 
                char __user *buf, size_t len, loff_t *off)
{
        struct irq_desc *desc;

        printk(KERN_INFO "Read function\n");
        desc = irq_to_desc(11);
        if (!desc) 
        {
            return -EINVAL;
        }
        __this_cpu_write(vector_irq[59], desc);
        asm("int $0x3B");  // Corresponding to irq 11
        return 0;
}

static int __init etx_driver_init(void)
{
  if(request_irq(IRQ_NO, irq_handler, IRQF_SHARED, "etx_device", (void *)(irq_handler)))
	{
		printk(KERN_INFO "my_device: cannot register IRQ ");
                    goto irq;
  }
  printk(KERN_INFO "Device Driver Insert...Done!!!\n");
  return 0;
 
irq:
  free_irq(IRQ_NO,(void *)(irq_handler));
 
r_sysfs:
        kobject_put(kobj_ref); 
        sysfs_remove_file(kernel_kobj, &etx_attr.attr);
 
r_device:
        class_destroy(dev_class);
r_class:
        unregister_chrdev_region(dev,1);
        cdev_del(&etx_cdev);
        return -1;
}
 
static void __exit etx_driver_exit(void)
{
        free_irq(IRQ_NO,(void *)(irq_handler));
        kobject_put(kobj_ref); 
        sysfs_remove_file(kernel_kobj, &etx_attr.attr);
        device_destroy(dev_class,dev);
        class_destroy(dev_class);
        cdev_del(&etx_cdev);
        unregister_chrdev_region(dev, 1);
        printk(KERN_INFO "Device Driver Remove...Done!!!\n");
}
 
module_init(etx_driver_init);
module_exit(etx_driver_exit);
 
MODULE_LICENSE("GPL");
MODULE_AUTHOR("EmbeTronicX <embetron[email protected]>");
MODULE_DESCRIPTION("A simple device driver - Interrupts");
MODULE_VERSION("1.9");

##########################################################################################


##########################################################################################


##########################################################################################


##########################################################################################



